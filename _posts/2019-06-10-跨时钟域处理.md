---
layout:     post
title:      跨时钟域处理
subtitle:   
date:       2019-06-10
author:     yzmb2411
header-img: 
catalog: 	 true
tags:
    - FPGA
    - Verilog
---
    跨时钟域处理是FPGA设计中经常遇到的问题，而如何处理好跨时钟域间的数据，可以说是每个FPGA初学者的必修课。跨时钟域处理也是面试中经常常被问到的一个问题。

    在本篇文章中，主要介绍3种跨时钟域处理的方法，这3种方法可以说是最常用也最实用的方法，这三种方法包含了单bit和多bit数据的跨时钟域处理。

## 本文介绍的3种方法跨时钟域处理方法如下

       1.打两拍；	  

       2.异步双口RAM；	   

       3.格雷码转换。	   

## 第一种方法：打两拍	

    大家很清楚，处理跨时钟域的数据有单bit和多bit之分，而打两拍的方式常见于处理单bit数据的跨时钟域问题。
 
 打两拍的方式，其实说白了，就是定义两级寄存器，对输入的数据进行延拍。如下图所示。	

![image](https://wxt.sinaimg.cn/mw1024/ab20a024ly1g3vydpnkh3j20i408tjsf.jpg?tags=%5B%5D)
    
	应该很多人都会问，为什么是打两拍呢，打一拍、打三拍行不行呢？

    先简单说下两级寄存器的原理：两级寄存是一级寄存的平方，两级并不能完全消除亚稳态危害，但是提高了可靠性减少其发生概率。总的来讲，就是一级概率很大，三级改善不大。
 
 这样说可能还是有很多人不够完全理解，那么请看下面的时序示意图：

![image](https://wx2.sinaimg.cn/mw1024/ab20a024ly1g3vyenh97sj20i607emxc.jpg)

    data是时钟域1的数据，需要传到时钟域2（clk）进行处理，寄存器1和寄存器2使用的时钟都为clk。	

	假设在clk的上升沿正好采到data的跳变沿（从0变1的上升沿，实际上的数据跳变不可能是瞬时的，所以有短暂的跳变时间），那这时作为寄存器1的输入到底应该是0还是1呢？	

	这是一个不确定的问题。所以Q1的值也不能确定，但至少可以保证，在clk的下一个上升沿，Q1基本可以满足第二级寄存器的保持时间和建立时间要求,出现亚稳态的概率得到了很大的改善。

    如果再加上第三级寄存器，由于第二级寄存器对于亚稳态的处理已经起到了很大的改善作用，第三级寄存器在很大程度上可以说只是对于第二级寄存器的延拍，所以意义是不大的。
 
    可能对于这部分的解释不是很到位，不过还是希望大家能够多思考一下，欢迎大家批评指正。

## 第二种方法：异步双口RAM	

    处理多bit数据的跨时钟域，一般采用异步双口RAM。假设我们现在有一个信号采集平台，ADC芯片提供源同步时钟60MHz，ADC芯片输出的数据在60MHz的时钟上升沿变化，而FPGA内部需要使用100MHz的时钟来处理ADC采集到的数据（多bit）。

    在这种类似的场景中，我们便可以使用异步双口RAM来做跨时钟域处理。先利用ADC芯片提供的60MHz时钟将ADC输出的数据写入异步双口RAM，然后使用100MHz的时钟从RAM中读出。

    对于使用异步双口RAM来处理多bit数据的跨时钟域，相信大家还是可以理解的。当然，在能使用异步双口RAM来处理跨时钟域的场景中，也可以使用异步FIFO来达到同样的目的。

## 第三种方法：格雷码转换

    对于第三种方法，Kevin在大学里边从没接触过，也是在工作中才接触到。

    我们依然继续使用介绍第二种方法中用到的ADC例子，将ADC采样的数据写入RAM时，需要产生RAM的写地址，但我们读出RAM中的数据时，肯定不是一上电就直接读取，而是要等RAM中有ADC的数据之后才去读RAM。
	
	这就需要100MHz的时钟对RAM的写地址进行判断，当写地址大于某个值之后再去读取RAM。

    在这个场景中，其实很多人都是使用直接用100MHz的时钟于RAM的写地址进行打两拍的方式，但RAM的写地址属于多bit，如果单纯只是打两拍，那不一定能确保写地址数据的每一个bit在100MHz的时钟域变化都是同步的，肯定有一个先后顺序。
	
	如果在低速的环境中不一定会出错，在高速的环境下就不一定能保证了。所以更为妥当的一种处理方法就是使用格雷码转换。

    对于格雷码，相邻的两个数间只有一个bit是不一样的（格雷码，在本文中不作详细介绍），如果先将RAM的写地址转为格雷码，然后再将写地址的格雷码进行打两拍，之后再在RAM的读时钟域将格雷码恢复成10进制。这种处理就相当于对单bit数据的跨时钟域处理了。	
	